package Requests.Computation;

import Requests.Computation.Expression.ExpressionParser;

import java.util.*;
import java.util.regex.Pattern;


public class ValuesParser {
    private final String VARIABLE_NAME_REGEX = ExpressionParser.TokenType.VARIABLE.toString();
    private final String string;
    private final ValuesKind kind;
    private List<VariableInterval> variables;

    public ValuesParser(String string, ValuesKind kind) {
        this.string = string.replace(" ", "");
        this.kind = kind;
        parseValues();
    }

    private void parseValues() {
        variables = new ArrayList<>();

        String[] variableStrings = string.split(",");
        if (variableStrings.length == 1 && variableStrings[0].equals("")) return;

        for (String variableString : variableStrings) {
            String[] tokens = variableString.split(":");
            if (tokens.length != 4) {
                throw new IllegalArgumentException("Invalid variable format for variable: " + variableString);
            }
            String varName = tokens[0];
            if (!Pattern.compile(VARIABLE_NAME_REGEX).matcher(varName).matches()) {
                throw new IllegalArgumentException("Invalid variable name for variable: " + variableString);
            }

            try {
                variables.add(new VariableInterval(varName,
                        Double.parseDouble(tokens[1]),
                        Double.parseDouble(tokens[2]),
                        Double.parseDouble(tokens[3])));
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException("Invalid value for variable " + variableString + ". " + e.getMessage());
            }
        }
    }

    // NOTE: specifications explicitly required to "2. build a list T of value tuples from a"
    //      this may result in outOfMemory error for large lists
    public List<Map<String, Double>> getTuples() {
        // WARNING: there's likely a much less convoluted way to implement this method, but this works
        List<Map<String, Double>> tuples = new ArrayList<>();
        if (variables.size() == 0) return tuples;

        Map<String, List<Double>> valuesListForVariable = new LinkedHashMap<>(); //linkedHashMap preserves order of the elements
        for (VariableInterval variable : variables) {
            if (valuesListForVariable.containsKey(variable.name)) {
                throw new IllegalArgumentException("2 variables with the same name were specified: " + variable.name);
            }
            valuesListForVariable.put(variable.name, variable.getVariableValuesList());
        }

        if (kind == ValuesKind.LIST) {
            if (valuesListForVariable.values().stream()
                            .map(List::size)
                            .distinct().count() > 1) { // check if lists have different sizes
                throw new IllegalArgumentException("The specified variable intervals do not have the same number of elements, impossible to use Values Kind LIST.");
            }
            for (int i = 0; i < valuesListForVariable.values().iterator().next().size(); i++) {
                Map<String, Double> tmpMap = new HashMap<>();
                for (VariableInterval variable : variables) {
                    tmpMap.put(variable.name, valuesListForVariable.get(variable.name).get(i));
                }
                tuples.add(tmpMap);
            }
        } else if (kind == ValuesKind.GRID) {
            computeGrid(valuesListForVariable, tuples, null);
        } else {
            throw new EnumConstantNotPresentException(ValuesKind.class, kind.toString());
        }
        return tuples;
    }

    /**
     * Starting from the lists of all the possible values for each variable, populates the list of all the possible tuples
     * @param valuesLists starting list of possible values for each variable
     * @param tuples final list of tuples
     * @param superMap tuple generated by the previous iteration level
     */
    private void computeGrid(Map<String, List<Double>> valuesLists, List<Map<String, Double>> tuples, Map<String, Double> superMap) {
        if (valuesLists.size() < 1) {
            throw new IllegalArgumentException("Empty variables list.");
        }
        String currentVariable = valuesLists.entrySet()
                .stream()
                .findFirst()
                .get().getKey();
        for (Double value : valuesLists.get(currentVariable)) {
            Map<String, Double> map = (superMap == null) ? new LinkedHashMap<>() : new LinkedHashMap<>(superMap);
            map.put(currentVariable, value);
            if (valuesLists.size() <= 1) { //stop condition
                tuples.add(map);
            } else {
                Map<String, List<Double>> subValuesLists = new LinkedHashMap<>(valuesLists);
                subValuesLists.remove(currentVariable);
                computeGrid(subValuesLists, tuples, map);
            }
        }
    }

    private static class VariableInterval {
        String name;
        double lower;
        double step;
        double upper;

        public VariableInterval(String name, double lower, double step, double upper) {
            if (step <= 0) {
                throw new IllegalArgumentException("Invalid step for variable " + name + ". Step must be strictly positive.");
            }
            this.name = name;
            this.lower = lower;
            this.step = step;
            this.upper = upper;
        }

        public List<Double> getVariableValuesList() {
            List<Double> values = new ArrayList<>();

            long i = 0;
            double d = lower;
            while (d <= upper) {
                values.add(d);
                i++;
                d = lower + step * i;
            }
            return values;
        }
    }

}
